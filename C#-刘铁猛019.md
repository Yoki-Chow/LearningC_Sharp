# 委托  
* 什么是委托  
* 委托的声明  
* 委托的使用  
# 什么是委托  
## 委托（delegate）  
* 委托是C语言中函数指针的升级版  
```c
typedef int(*Calc)(int a,int b);  

Calc funcPoint1 = &Add;
Calc funcPoint2 = &Sub;
```  
其实就是C语言中的直接调用和间接调用  

下面是C#委托的一个简单例子  
```cs
namespace sss
{
    class Program
    {
        static void Main(string[] args)
        {
            Calculator calculator = new Calculator();//创建实例才能使用它的方法
            Action 方法 = new Action(calculator.Report);
            calculator.Report();//直接调用
            action.Invoke();//间接调用
            action();//这行是上面间接调用的简写

            Func<int,int,int> func1 = new Func<int,int,int>(calculator.Add);
            Func<int,int,int> func2 = new Func<int,int,int>(calculator.Sub);

            int x = 100;
            int y = 200;
            int z = 0;

            z = func1.Invoke(x,y);
            Console.WriteLine(z);
            z = func2.Invoke(x,y);
            Console.WriteLine(z);
        }
    }

    class Calculator
    {
        public void Report()
        {
            Console.WriteLine("I have 3 methods");
        }

        public int Add(int x,int y)
        {
            int result = x + y;
            return result;
        }

        public int Sub(int x,int y)
        {
            int result = x - y;
            return result;
        }
    }
}
```
## 一切皆地址 
## 直接调用与间接调用  
## 委托的简单使用  

# 委托的声明（自定义委托）
* 委托是一种类（Class），类是数据类型所以委托也是一种数据类型
* 他的声明方式与一般的类不同，主要是为了照顾可读性和C/C++的传统去  
```cs
namespace Delegate
{
    public delegate double Calc(double x,double y);

    class Program
    {
        static void Main(string[] args)
        {
            Calculator calculator = new Calculator();
            Calc c1 = new Calc(calculator.Add);
            Calc c2 = new Calc(calculator.Sum);

            double a = 100;
            double b = 200;
            double c = 0;

            c = calc1(a,b);
            c = calc2(a,b);

        }
    }

    class Calculator
    {
        public double Add(double x,double y)
        {
            return x + y;
        }

        public double Sub(double x,double y)
        {
            return x - y;
        }

    }
}
```

* 注意声明委托的位置，避免写错地方结果声明成嵌套类型  
* 委托与所封装的方法必须“类型兼容”  
    * 返回值的数据类型一致  
    * 参数列表在个数和数据类型上一致（参数名称可以不一样，但数据类型必须要相同）
```cs
delegate double Calc(double x,double y);
         double Add(double x,double y){return x + y;}
         double Sub(double x,double y){return x - y;}
         double Mul(double x,double y){return x * y;}
         double Div(double x,double y){return x / y;}
```

# 委托的一般使用  
## 实例：把方法当作参数传给另一个方法
* “模板方法”：通过借用指定的外部方法来产生结果
   * 相当于一道填空题,在空中填入需要的方法
   * 一般位于代码的中部位置 
   * 委托有返回值  
```cs
namespace Delegate
{
    class Program
    {
        static void Main(string[] args)
        {
        }
    }

    class Product
    {
        public string Name {get;set;}
    }

    class Box
    {
        public Product Product{get;set;}
    }
   
}
```

* 回调方法（callback），调用指定的外部方法
    * 相当于流水线，我可以不用，但是你不能没有
    * 通常位于代码的末尾
    * 委托无返回值 
```cs
namespace Delegate
{
    public delegate double Calc(double x,double y);

    class Program
    {
        static void Main(string[] args)
        {
            Calculator calculator = new Calculator();
            Calc c1 = new Calc(calculator.Add);
            Calc c2 = new Calc(calculator.Sum);

            double a = 100;
            double b = 200;
            double c = 0;

            c = calc1(a,b);
            c = calc2(a,b);

        }
    }

    class Calculator
    {
        public double Add(double x,double y)
        {
            return x + y;
        }

        public double Sub(double x,double y)
        {
            return x - y;
        }

    }
}
``` 

## 注意！
切记不可乱用，
* 原因1：这是一种方法级别的紧耦合，使用时请慎重  
* 原因2：会导致可读性下降、debug的难度增加  
* 原因3：把委托回调、异步调用和多线曾纠缠在一起，会让代码变成屎山
* 原因4：委托使用不当可能会造成内存泄漏和程序的性能下降  
